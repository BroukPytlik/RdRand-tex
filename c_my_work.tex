%=========================================================================

\chapter{My work} \label{sec:my-work}
According the needs of RedHat I created a library providing basic interface over the RdRand instruction as well as a simple application using this library.

\TODO{fedora package} % TODO Fedora Package

\section{The library}  \label{sec:library}


\section{The library - API} \label{sec:library-api}
The library, if installed into the system, can be included by using {\tt \#include <rdrand-VERSION/rdrand.h>}. In the time of this work, the library is using the following API.

\subsection{Constants}
\begin{description}
  \item[RDRAND\_SUCCESS] Returned by function if a random number(s) was generated correctly.
  \item[RDRAND\_FAILURE] Returned by function if a random number(s) was NOT generated correctly.
  \item[RDRAND\_SUPPORTED] Returned by \function{rdrand_testSupport} function if the CPU support RdRand.
  \item[RDRAND\_UNSUPPORTED] Returned by \function{rdrand_testSupport} function if the CPU doesn't know RdRand.
  
\end{description}


\subsection{Functions}

\subsubsection{Non-generating functions}

These functions are not generating any random numbers.\\

\FunctionDeclare{int}{rdrand_testSupport}{void}{Detect if the CPU support RdRand instruction. Returns {\tt RDRAND_SUPPORTED}  or {\tt RDRAND_UNSUPPORTED}.}\\

\subsubsection{Simple wrappers}
These methods are simply wrappers of an ASM code which generates only one n-bits number. Although these functions are provided, I expect that they will be used only infrequently. Returns {\tt RDRAND\_SUCCESS} or {\tt RDRAND\_FAILURE}.\\

\FunctionDeclare{int}{rdrand16_step}{uint16\_t *x}{Generates 16 bits of entropy through RdRand.}\\

\FunctionDeclare{int}{rdrand32_step}{uint32\_t *x}{Generates 32 bits of entropy through RdRand.}\\

\FunctionDeclare{int}{rdrand64_step}{uint64\_t *x}{Generates 64 bits of entropy through RdRand.}\\

\subsubsection{Generating single value}
More complex functions than the previous -- in case of RdRand failure, these functions will try it again for the specified amount of times. Negative {\tt retry\_limit} implies default value with which the library is compiled. Returns {\tt RDRAND\_SUCCESS} or {\tt RDRAND\_FAILURE}.\\


\FunctionDeclare{int}{rdrand_get_uint16_retry}{uint16\_t *x, int retry\_limit}{Generates 16 bits of entropy through RdRand.}\\

\FunctionDeclare{int}{rdrand_get_uint32_retry}{uint32\_t *x, int retry\_limit}{Generates 32 bits of entropy through RdRand.}\\

\FunctionDeclare{int}{rdrand_get_uint64_retry}{uint64\_t *x, int retry\_limit}{Generates 64 bits of entropy through RdRand.}\\

\subsubsection{Generating longer values}
As a single random value is usually not enough, the library provides also functions for generating multiple bytes of random values. For higher speed, all these functions are generating values in 64bit blocks when it is possible.
These functions also accept {\tt retry\_limit} as the previous ones. Returns bytes of sucessfully generated values.\\


\FunctionDeclare{size\_t}{rdrand_get_bytes_retry}{void *dest, const size\_t size, int retry\_limit}{Generate {\tt size} bytes of random data.}\\


\FunctionDeclare{size\_t}{rdrand_get_uint64_array_retry}{void *dest, const unsigned int count, int retry\_limit}{Generate {\tt count} of 64bit blocks of random data.}\\

\FunctionDeclare{size\_t}{rdrand_get_uint32_array_retry}{void *dest, const unsigned int count, int retry\_limit}{Generate {\tt count} of 32bit blocks of random data.}\\

\FunctionDeclare{size\_t}{rdrand_get_uint16_array_retry}{void *dest, const unsigned int count, int retry\_limit}{Generate {\tt count} of 16bit blocks of random data.}\\

\FunctionDeclare{size\_t}{rdrand_get_uint8_array_retry}{void *dest, const unsigned int count, int retry\_limit}{Generate {\tt count} of 8bit blocks of random data.}\\

\FunctionDeclare{size\_t}{rdrand_fwrite}{FILE *f, const size\_t count, int retry\_limit}{Generate {\tt count} bytes of random values and write it to the {\tt f} stream}\\

\subsubsection{Secure generating}
As is documented in the chapter~\nameref{sec:rdrand-instruction}, the CPU is using an~pseudorandom generator in~connection with an~entropy source. If the~user want to avoid of the~risk of~lower entropy for some reason, it is possible to use these functions, that~guarantee by~reseeding the internal entropy pool, that each~64bit generated value is independent on the~previous or the~next one. For the~principle, also see \nameref{sec:rdrand-instruction} chapter.\\



\FunctionDeclare{size\_t}{rdrand_get_uint64_array_reseed_delay}{uint64\_t *dest, const size\_t count, int retry\_limit}{Generate {\tt count} of 64bit values. Force reseed by waiting few microseconds before each generating.}\\


\FunctionDeclare{size\_t}{rdrand_get_uint64_array_reseed_skip}{uint64\_t *dest, const size\_t count, int retry\_limit}{Generate {\tt count} of 64bit values. Force reseed by generating and throwing away 1024 values per one saved.}\\


\section{The generator} \label{sec:generator}
\TODO{give the app a name} % TODO give the app a name

Because the library is only for C~language, using it for example with shell scripts would be difficult. For this reason I have created also a~simple executable application, which is installed with the~library, and which can be used for generating random values without the~need of using C~language.

The generator has four optional command-line parameters to~modify its behavior. Firstly, {\tt --amount} can be used to generate specific amount of~bytes of~randomness. Suffixes K, M, G and T are accepted for easier use and when this option is not used, then the~application is generating indefinitely until it is stopped, for example by KILL signal.

The second parameter is {\tt --method}, which allows user to change the default method \function{rdrand_get_bytes_retry} for the~two reseeding functions. The~names of the~methods are made shorter for the~interaction with the~user. Third parameter {\tt --output} is used for specifying the output file -- without it, the random values are printed on {\tt stdout}. 

The {\tt --threads} can specify, how many threads the~generator will run in parallel for better performance. By default it is set to 4, because according of Intel~\cite{IntelArk}, in Ivy Bridge generation of CPUs, in which the~instruction was added, only Celeron and Pentium families has less than 4 processing units.

\TODO{What families RdRand has? All?} % TODO What families RdRand has? All?

\subsection{Underflow recovery}
Although is stated in Intel's Software Developer Manual~\cite{IntelSWManualVol1}, chapter 7.3.17, that an exceeding of the speed of the internal generator is unlikely, and according of {\bf unverified} information on StackOverflow~\cite{StackoverflowRDRANDCharacteristics} it should not be possible in current generations (specifically on Ivy Bridge) of Intel's CPU to achieve it, we decided that the application should be working with good performance even in case of slower internal generator. The importance of this decision become even more obvious after finding that on \machine{dell-pr1700-02.lab.bos.redhat.com} the CPU wasn't able to handle more than four parallel threads reading from RdRand\footnote{Unfortunately, I cannot provide a statistic probability of such situation -- only one machine from all I have tried had this problem.}.

The principle is simple: By default, there is tolerance for few failures, implemented in the library itself, when a new call of the RdRand instruction is make immediately. But if amount of the failures in a row exceeds a limit with which the generator application was compiled, then there is a need for another approach; it is necessary to be able to work even on CPU with slow generator, yet still be able to detect complete failure of the HW.

In the case of exceeding of the HW RNG speed, the generator application tries to lower its own speed to get aligned with HW. This is at first done by decrementing threads count by one and new try. If this solution is not working or is not possible (that means, when the threads count was lowered to a single thread, or was so from the beginning), delays are being inserted between calls. The delays are then lengthened with each unsuccessful call. If even in this case the HW RNG is not able to provide enough random values, the application ends with an error message\footnote{Such situation would be clearly a sign of a hardware error and thus it is questionable if the generated values would be still really random}.

\section{Tests} \label{sec:tests}
For the need of performance testing I wrote another application, as well as small set of scripts for automating of tests. And after getting the code on decent performance, I also used some statistical tests batteries.

\subsection{Performance test}
Because the performance of the RNG is important, I needed to check the performance during the development on different machines and with different amount of threads. With manual testing it would be difficult to test the library in range (for example) from 1 to 120 threads.

\subsection{Scripts}
The set of Bash and Python scripts is there for automatic run of the throughput test with different count of threads, parsing the values and then creating a graph. You can see the outputs in chapter \nameref{sec:performance}.

\subsection{Statistical test}


%=========================================================================